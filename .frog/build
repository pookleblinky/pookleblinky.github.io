((3) 0 () 6 ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-spinning-it-up.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-frog.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-git-koans.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-26-languages.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-23-exercism.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-first-post.md" . unix)) () (h ! (equal) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-frog.md" . unix) f post (u . "Frog") (? . 1) 1495354682 (p+ #"/home/pook/pookleblinky.github.io/2017/05/frog.html" . unix) (u . "/2017/05/frog.html") (u . "2017-05-21T03:41:31") (? . 0) (? . 2) (c (u . "meta") c (u . "scheme")) (u . "\n<p>I made a Frog branch, init&rsquo;d a frog instance, and am now configuring it a bit before attempting to push it to the main site. Dunno exactly how the switch will go, but I can tell it&rsquo;s already a lot nicer than Jekyll.</p>") #t (u . "\n<p>I made a Frog branch, init&rsquo;d a frog instance, and am now configuring it a bit before attempting to push it to the main site. Dunno exactly how the switch will go, but I can tell it&rsquo;s already a lot nicer than Jekyll.</p>\n<!-- more-->")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-spinning-it-up.md" . unix) f post (u . "Spinning it up") (? . 0) 1495357710 (p+ #"/home/pook/pookleblinky.github.io/2017/05/spinning-it-up.html" . unix) (u . "/2017/05/spinning-it-up.html") (u . "2017-05-20T03:41:31F") (? . 5) (? . 1) (c (u . "meta")) (u . "\n<p>So, I&rsquo;ve set up a blog. Creating it was the easy part. Configuring it turned out to be more difficult. <a href=\"https://stackoverflow.com/questions/31327045/switch-theme-in-an-existing-jekyll-installation\">Switching from an existing Jekyll layout</a> Turns out to be a pain in the ass. So, I&rsquo;m just not gonna switch.</p>\n\n<p>Then, I broke permalinks, made pages load weird by duplicating the _layouts which the default theme doesn&rsquo;t require (Ah, there&rsquo;s that annoying ruby magic), and then broke more shit. Repeatedly broke shit for a while, seeing what&rsquo;s hidden in the ruby magic. More annoyingly, the localhost preview doesn&rsquo;t indicate some things are broken, you only discover them after pushing to the server. I will probably end up changing from Jekyll, and then building my own static site generator (this seems to be the main sequence of using github pages).</p>\n\n<p>Now I just have to figure out what to write. Years of using twitter have left me unable to write in long chunks. In threads, you still get accustomed to chunking thoughts into small enough pieces to fit into tweets. The luxurious space afforded to a blogpost is overwhelming.</p>\n\n<p>What to write? Well, the question is really what <em>not</em> to write. I write constantly, but in tweets and toots. I need to make writing twitter threads more annoying than writing here.</p>\n\n<p>This is a wonderful opportunity to streamline my workflow, on every level: from editing to git. So many things that can be automated away, so much grudgework eliminated. I have a feeling many of my first posts will just be me discovering new ways to break shit, intentionally or by accident.</p>") #f (u . "\n<p>So, I&rsquo;ve set up a blog. Creating it was the easy part. Configuring it turned out to be more difficult. <a href=\"https://stackoverflow.com/questions/31327045/switch-theme-in-an-existing-jekyll-installation\">Switching from an existing Jekyll layout</a> Turns out to be a pain in the ass. So, I&rsquo;m just not gonna switch.</p>\n\n<p>Then, I broke permalinks, made pages load weird by duplicating the _layouts which the default theme doesn&rsquo;t require (Ah, there&rsquo;s that annoying ruby magic), and then broke more shit. Repeatedly broke shit for a while, seeing what&rsquo;s hidden in the ruby magic. More annoyingly, the localhost preview doesn&rsquo;t indicate some things are broken, you only discover them after pushing to the server. I will probably end up changing from Jekyll, and then building my own static site generator (this seems to be the main sequence of using github pages).</p>\n\n<p>Now I just have to figure out what to write. Years of using twitter have left me unable to write in long chunks. In threads, you still get accustomed to chunking thoughts into small enough pieces to fit into tweets. The luxurious space afforded to a blogpost is overwhelming.</p>\n\n<p>What to write? Well, the question is really what <em>not</em> to write. I write constantly, but in tweets and toots. I need to make writing twitter threads more annoying than writing here.</p>\n\n<p>This is a wonderful opportunity to streamline my workflow, on every level: from editing to git. So many things that can be automated away, so much grudgework eliminated. I have a feeling many of my first posts will just be me discovering new ways to break shit, intentionally or by accident.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-git-koans.md" . unix) f post (u . "Git koans") (? . 2) 1495414206 (p+ #"/home/pook/pookleblinky.github.io/2017/05/git-koans.html" . unix) (u . "/2017/05/git-koans.html") (u . "2017-05-21T18:59:32") (? . 1) (? . 4) (c (u . "git") c (u . "coding") c (u . "rant")) (u . "\n<p>Git Koans don&rsquo;t really exist. I can&rsquo;t be arsed to make it, though. There are some anecdotes called Git Koans, but as far as I can tell there is nothing similar to Clojure/Ruby Koans where you get hands-on experience fixing things incrementally, from tiny mistakes all the way up the ladder.</p>\n\n<p>Basically: &ldquo;Here&rsquo;s broken shit. Fix it.&rdquo; &ldquo;Yay, you fixed it. Here&rsquo;s more broken shit. Fix it.&rdquo; Turn on continuous integration and use post-commit hooks as the koan runner. Eventually, you fix all the problems in the broken repo.</p>\n\n<p>It actually wouldn&rsquo;t be very hard. You can pretty much use any kind of make system to build a repo then fuck it up per order. The result would be hands-on experience fixing fuckups in git, from small to huge. Hell: a joker shell script that takes all the commands used to evolve a repo, and randomly inserts typos and wrong commands to fuck it up (Maybe just swap the entered command with one which is often accidentally typed instead). &ldquo;Here&rsquo;s a fork of Foo that&rsquo;s been utterly fucked. Walk through its history and unfuck it.&rdquo;</p>\n\n<p>You could also do local/remote fuckups pretty easily too. Have a shell script that purposely messes up upstream/downstream relations, purposely screws up a merge, etc. Nightmare mode: multiple remotes are created, each randomly screwed up to simulate others trying, unsuccessfully, to fix their own messed up repos.</p>\n\n<p>As far as I can tell, this doesn&rsquo;t exist. The only time you&rsquo;re ever fixing a fuckup is in actual goddamn repos during your job. The <em>only</em> time you will ever unfuck an arbitrarily broken repo is when your ass depends on it.</p>\n\n<p>This means that for most people, git is a <a href=\"https://people.csail.mit.edu/sperezde/oopsla16.pdf\">cargo cult</a>. You don&rsquo;t know how to unfuck things, you&rsquo;re doing shit like cp -R repo repo.old. Imagine if you wrote code this way: the <em>only</em> time you ever fix bugs is in production code. The only time you ever fix a bug is when your ass is on the line. You&rsquo;d also do cargo cult bullshit. You&rsquo;d be that happy asshole sloppily commenting out lines of code to see what&rsquo;s wrong. In $Lang the Hard Way style tutorials, it&rsquo;s heavily emphasized that you should break stuff in order to learn what happens, and how to fix it when you do inevitably do it by accident. Yet, I would put money on the bet that the vast majority of git users have never purposely broken a repo in order to learn how to fix it. How many purposely messed up a commit or 3 in order to get hands-on experience with git reflog? How many intentionally committed to the wrong branch so they could learn how to stash pop. How many purposely introduced a painful merge conflict in order to learn the right (painless) way to resolve it? Purposely broke the build in order to learn how to use bisect?</p>\n\n<p>In code, it&rsquo;s unthinkable that you would have no experience of fixing bugs outside of &ldquo;we need this fixed yesterday&rdquo; situations. Yet with git, that&rsquo;s the case. No experience, at all, of unfucking repos that you don&rsquo;t depend on for rent or whatever. The average git user has no idea how to fix mistakes they make, and every mistake they do have to fix is only ever on a real repo.</p>\n\n<p>Look at <a href=\"http://ohshitgit.com/\">Oh Shit Git</a>. It lists very common mistakes, in plain English, and explains how to fix them. I guarantee that the vast majority of git users have never <em>purposely</em> made those mistakes in order to see how to fix them. For many, the first time they have to fix a mistake, that mistake is new to them and they end up on ohshitgit or stackoverflow typing commands that may as well be mystic incantations.</p>") #f (u . "\n<p>Git Koans don&rsquo;t really exist. I can&rsquo;t be arsed to make it, though. There are some anecdotes called Git Koans, but as far as I can tell there is nothing similar to Clojure/Ruby Koans where you get hands-on experience fixing things incrementally, from tiny mistakes all the way up the ladder.</p>\n\n<p>Basically: &ldquo;Here&rsquo;s broken shit. Fix it.&rdquo; &ldquo;Yay, you fixed it. Here&rsquo;s more broken shit. Fix it.&rdquo; Turn on continuous integration and use post-commit hooks as the koan runner. Eventually, you fix all the problems in the broken repo.</p>\n\n<p>It actually wouldn&rsquo;t be very hard. You can pretty much use any kind of make system to build a repo then fuck it up per order. The result would be hands-on experience fixing fuckups in git, from small to huge. Hell: a joker shell script that takes all the commands used to evolve a repo, and randomly inserts typos and wrong commands to fuck it up (Maybe just swap the entered command with one which is often accidentally typed instead). &ldquo;Here&rsquo;s a fork of Foo that&rsquo;s been utterly fucked. Walk through its history and unfuck it.&rdquo;</p>\n\n<p>You could also do local/remote fuckups pretty easily too. Have a shell script that purposely messes up upstream/downstream relations, purposely screws up a merge, etc. Nightmare mode: multiple remotes are created, each randomly screwed up to simulate others trying, unsuccessfully, to fix their own messed up repos.</p>\n\n<p>As far as I can tell, this doesn&rsquo;t exist. The only time you&rsquo;re ever fixing a fuckup is in actual goddamn repos during your job. The <em>only</em> time you will ever unfuck an arbitrarily broken repo is when your ass depends on it.</p>\n\n<p>This means that for most people, git is a <a href=\"https://people.csail.mit.edu/sperezde/oopsla16.pdf\">cargo cult</a>. You don&rsquo;t know how to unfuck things, you&rsquo;re doing shit like cp -R repo repo.old. Imagine if you wrote code this way: the <em>only</em> time you ever fix bugs is in production code. The only time you ever fix a bug is when your ass is on the line. You&rsquo;d also do cargo cult bullshit. You&rsquo;d be that happy asshole sloppily commenting out lines of code to see what&rsquo;s wrong. In $Lang the Hard Way style tutorials, it&rsquo;s heavily emphasized that you should break stuff in order to learn what happens, and how to fix it when you do inevitably do it by accident. Yet, I would put money on the bet that the vast majority of git users have never purposely broken a repo in order to learn how to fix it. How many purposely messed up a commit or 3 in order to get hands-on experience with git reflog? How many intentionally committed to the wrong branch so they could learn how to stash pop. How many purposely introduced a painful merge conflict in order to learn the right (painless) way to resolve it? Purposely broke the build in order to learn how to use bisect?</p>\n\n<p>In code, it&rsquo;s unthinkable that you would have no experience of fixing bugs outside of &ldquo;we need this fixed yesterday&rdquo; situations. Yet with git, that&rsquo;s the case. No experience, at all, of unfucking repos that you don&rsquo;t depend on for rent or whatever. The average git user has no idea how to fix mistakes they make, and every mistake they do have to fix is only ever on a real repo.</p>\n\n<p>Look at <a href=\"http://ohshitgit.com/\">Oh Shit Git</a>. It lists very common mistakes, in plain English, and explains how to fix them. I guarantee that the vast majority of git users have never <em>purposely</em> made those mistakes in order to see how to fix them. For many, the first time they have to fix a mistake, that mistake is new to them and they end up on ohshitgit or stackoverflow typing commands that may as well be mystic incantations.</p>")) ((? . 3) f post (u . "languages") (? . 3) 1495784035 (p+ #"/home/pook/pookleblinky.github.io/2017/05/languages.html" . unix) (u . "/2017/05/languages.html") (u . "2017-05-26T03:04:55") (? . 4) #f (c (u . "languages") c (u . "dev environment") c (u . "workflow") c (u . "learning")) (u . "\n<p>I tend to get flustered when learning languages. I bounce from one to another, trying the same thing in each. &ldquo;oh cool how would I do this in foo? Ah, gotta yakshave my emacs for bar&rdquo;</p>\n\n<p>Little ends up getting done, and I end up working at a cartoonishly slow pace as I bounce around playing with everything.</p>\n\n<p>Right now, I&rsquo;m focusing on Racket, Elixir, Clojure, and Common Lisp. oCaml, LFE, and Haskell as background noise, not the main focus.</p>\n\n<p>That&rsquo;s a lot of opportunity to get distracted on several levels, from other languages to yakshaving dev environments and workflows for them.</p>\n\n<p>For instance, my normal workflow involves vim-slime and tmux. Vim-slime sends text to a specified tmux pane, it doesn&rsquo;t know or care what repl is on the other end. It doesn&rsquo;t know or care about nrepl or swank or any of that. Just where to dump the text. I prefer this over magic. Well, in LFE slurping a file into the repl dumps all previously slurped macros and defs. The repl is more stateful than most, so the workflow is a little awkward. I was pondering how to tweak vim-slime to have an LFE mode that would on C-c C-c first save, then send over the text (c \"@%\"), or something. I could yakshave on this happily, but it&rsquo;s a distraction.</p>\n\n<p>My attempted solution is simple. For focus, I&rsquo;m using exercism. Each language is on a different track, each has defined tasks to accomplish and progress is tracked. Most tracks have similar tasks, which nicely satisfies my &ldquo;oh man I wonder how I&rsquo;d do this in foo&rdquo; impulse, but in a structured and focused way. Yakshaving is kept to a minimum: while working in racket, I can pop over to another pane, type &ldquo;langjournal,&rdquo; and note a todo about yakshaving vim to work better with it. Later, I can yakshave, but I can keep focused on what I was doing instead of falling down the rabbit hole.</p>\n\n<p>While doing the erlang track, I saw that rebar.config hardcoded rebar3. I did the task, gsubbed rebar3 to rebar (v2 is what I had), and ran the tests. They passed, I made a note. Went on #erlang, asked about rebar3, and decided to upgrade. I bootstrapped it in less than a minute, reverted rebar.config, and it worked as intended. Minimal yakshaving.</p>\n\n<p>I figure as long as I keep things structured, push yakshaving out of the way into its own activity (&ldquo;today I&rsquo;m gonna get vim to work better with lfe&rdquo;), and avoid temptation, I&rsquo;ll have a much nicer time than my usual habits provide.</p>\n\n<p>This blog is going to be part of my workflow, forcing me to maintain a coherency which is usually lost reinventing a local PLEAC.</p>") #f (u . "\n<p>I tend to get flustered when learning languages. I bounce from one to another, trying the same thing in each. &ldquo;oh cool how would I do this in foo? Ah, gotta yakshave my emacs for bar&rdquo;</p>\n\n<p>Little ends up getting done, and I end up working at a cartoonishly slow pace as I bounce around playing with everything.</p>\n\n<p>Right now, I&rsquo;m focusing on Racket, Elixir, Clojure, and Common Lisp. oCaml, LFE, and Haskell as background noise, not the main focus.</p>\n\n<p>That&rsquo;s a lot of opportunity to get distracted on several levels, from other languages to yakshaving dev environments and workflows for them.</p>\n\n<p>For instance, my normal workflow involves vim-slime and tmux. Vim-slime sends text to a specified tmux pane, it doesn&rsquo;t know or care what repl is on the other end. It doesn&rsquo;t know or care about nrepl or swank or any of that. Just where to dump the text. I prefer this over magic. Well, in LFE slurping a file into the repl dumps all previously slurped macros and defs. The repl is more stateful than most, so the workflow is a little awkward. I was pondering how to tweak vim-slime to have an LFE mode that would on C-c C-c first save, then send over the text (c \"@%\"), or something. I could yakshave on this happily, but it&rsquo;s a distraction.</p>\n\n<p>My attempted solution is simple. For focus, I&rsquo;m using exercism. Each language is on a different track, each has defined tasks to accomplish and progress is tracked. Most tracks have similar tasks, which nicely satisfies my &ldquo;oh man I wonder how I&rsquo;d do this in foo&rdquo; impulse, but in a structured and focused way. Yakshaving is kept to a minimum: while working in racket, I can pop over to another pane, type &ldquo;langjournal,&rdquo; and note a todo about yakshaving vim to work better with it. Later, I can yakshave, but I can keep focused on what I was doing instead of falling down the rabbit hole.</p>\n\n<p>While doing the erlang track, I saw that rebar.config hardcoded rebar3. I did the task, gsubbed rebar3 to rebar (v2 is what I had), and ran the tests. They passed, I made a note. Went on #erlang, asked about rebar3, and decided to upgrade. I bootstrapped it in less than a minute, reverted rebar.config, and it worked as intended. Minimal yakshaving.</p>\n\n<p>I figure as long as I keep things structured, push yakshaving out of the way into its own activity (&ldquo;today I&rsquo;m gonna get vim to work better with lfe&rdquo;), and avoid temptation, I&rsquo;ll have a much nicer time than my usual habits provide.</p>\n\n<p>This blog is going to be part of my workflow, forcing me to maintain a coherency which is usually lost reinventing a local PLEAC.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-first-post.md" . unix) f post (u . "first post") (? . 5) 1495357660 (p+ #"/home/pook/pookleblinky.github.io/2017/05/first-post.html" . unix) (u . "/2017/05/first-post.html") (u . "2017-05-20T03:41:31") #f (? . 0) (c (u . "meta")) (u . "\n<p>After so long on twitter, I&rsquo;m unused to longform writing, despite all my threads. I&rsquo;m used to expressing things 140 characters at a time, as this paragraph indicates.</p>\n\n<p>This will be my first foray into longform writing in a while. I&rsquo;ll probably end up parasitizing off my twitter threads.</p>\n\n<p>About this site: I figured I wanted to blog, but I never want to leave vim/emacs to do it. Setting up a github static page with Jekyll was the laziest possible way to accomplish this. Literally took 5 minutes.</p>\n\n<p>Edit: Immediately switched to <a href=\"https://github.com/greghendershott/frog\">Frog</a>, which is a static site generator written in Racket which works on Google Pages. Spinning that up was a little more work, as GP doesn&rsquo;t let you simply branch, install an alternate generator, and set that second branch as the display. Still, took only a few minutes.</p>") #f (u . "\n<p>After so long on twitter, I&rsquo;m unused to longform writing, despite all my threads. I&rsquo;m used to expressing things 140 characters at a time, as this paragraph indicates.</p>\n\n<p>This will be my first foray into longform writing in a while. I&rsquo;ll probably end up parasitizing off my twitter threads.</p>\n\n<p>About this site: I figured I wanted to blog, but I never want to leave vim/emacs to do it. Setting up a github static page with Jekyll was the laziest possible way to accomplish this. Literally took 5 minutes.</p>\n\n<p>Edit: Immediately switched to <a href=\"https://github.com/greghendershott/frog\">Frog</a>, which is a static site generator written in Racket which works on Google Pages. Spinning that up was a little more work, as GP doesn&rsquo;t let you simply branch, install an alternate generator, and set that second branch as the display. Still, took only a few minutes.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-23-exercism.md" . unix) f post (u . "Exercism") (? . 4) 1495576210 (p+ #"/home/pook/pookleblinky.github.io/2017/05/exercism.html" . unix) (u . "/2017/05/exercism.html") (u . "2017-05-23T17:39:35") (? . 2) (? . 3) (c (u . "resources")) (u . "\n<p>On #Racket, samth linked to <a href=\"http://exercism.io/languages/racket\">Exercism</a>, a wonderful analog to $LANG Koans. Each exercise is a basic, small program which you code by satisfying the unit tests. Unlike, say, Clojure Koans, <a href=\"http://exercism.io/languages/clojure\">the Clojure Track of Exercism</a> has you create 58 programs of various degrees of complexity, rather than a running through individual test assertions.</p>\n\n<p>You code enough to pass the tests, then submit. You can keep tweaking your solution, and keep submitting it. On your dashboard, you&rsquo;ll be able to see how your solution has evolved over time. You can also look at how other people solved the problem, discuss solutions, etc.</p>\n\n<p>Exercism, with its emphasis on creating programs and then discussing them, is an even better way to introduce a language than a standard koan runner. Especially considering that if you already know the language, instead of solving the exercises you can easily submit new ones for others to solve.</p>") #f (u . "\n<p>On #Racket, samth linked to <a href=\"http://exercism.io/languages/racket\">Exercism</a>, a wonderful analog to $LANG Koans. Each exercise is a basic, small program which you code by satisfying the unit tests. Unlike, say, Clojure Koans, <a href=\"http://exercism.io/languages/clojure\">the Clojure Track of Exercism</a> has you create 58 programs of various degrees of complexity, rather than a running through individual test assertions.</p>\n\n<p>You code enough to pass the tests, then submit. You can keep tweaking your solution, and keep submitting it. On your dashboard, you&rsquo;ll be able to see how your solution has evolved over time. You can also look at how other people solved the problem, discuss solutions, etc.</p>\n\n<p>Exercism, with its emphasis on creating programs and then discussing them, is an even better way to introduce a language than a standard koan runner. Especially considering that if you already know the language, instead of solving the exercises you can easily submit new ones for others to solve.</p>"))))