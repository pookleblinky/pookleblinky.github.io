((3) 0 () 7 ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-spinning-it-up.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-first-post.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-frog.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-26-clojure-annoyances-1.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-26-languages.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-git-koans.md" . unix) (p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-23-exercism.md" . unix)) () (h ! (equal) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-26-languages.md" . unix) f post (u . "languages") (? . 4) 1495793895 (p+ #"/home/pook/pookleblinky.github.io/2017/05/languages.html" . unix) (u . "/2017/05/languages.html") (u . "2017-05-26T03:04:55") (? . 6) (? . 3) (c (u . "languages") c (u . "dev environment") c (u . "workflow") c (u . "learning")) (u . "\n<p>I tend to get flustered when learning languages. I bounce from one to another, trying the same thing in each. &ldquo;oh cool how would I do this in foo? Ah, gotta yakshave my emacs for bar.&rdquo; Since every programming language sucks, I end up endlessly plunging down rabbit holes trying to yakshave things to work properly and smoothly. My focus gets distributed among n languages, m setups, and p annoyances. In this vast space, I end up wandering stochastically and occasionally bumping into useful things. This is no way to conquer a territory and hear the dialup modem screeching lamentations of its robots as you chase them before you.</p>\n\n<p>Little ends up getting done, and I end up working at a cartoonishly slow pace as I bounce around playing with everything. Despite learning, I end up with little to show for it, and the lack of structure means I end up following an interesting avenue and completely neglecting what is usually considered a vital part of the language.</p>\n\n<p>Right now, I&rsquo;m focusing on Racket, Elixir, Clojure, and Common Lisp. oCaml, LFE, and Haskell as background noise, not the main focus. Clojure is a bit lower priority than Elixir; it&rsquo;s just not a good lisp and the dev is not fun on a low-end device. Elixir is a better lisp than clojure and it&rsquo;s not even trying. It didn&rsquo;t even bother to bring its bag full of parentheses to the party and it still kicks clojure&rsquo;s ass. Reminder to rant about this later.</p>\n\n<p>That&rsquo;s a lot of opportunity to get distracted on several levels, from other languages to yakshaving dev environments and workflows for them.</p>\n\n<p>For instance, my normal workflow involves vim-slime and tmux. Vim-slime sends text to a specified tmux pane, it doesn&rsquo;t know or care what repl is on the other end. It doesn&rsquo;t know or care about nrepl or swank or any of that. Just where to dump the text. I prefer this over magic. Well, in LFE slurping a file into the repl dumps all previously slurped macros and defs. The repl is more stateful than most, so the workflow is a little awkward. I was pondering how to tweak vim-slime to have an LFE mode that would on C-c C-c first save, then send over the text (c \"@%\"), or something. I could yakshave on this happily, but it&rsquo;s a distraction. I&rsquo;m trying to minimize as much as possible the temptation to yakshave, so I forced myself mid-fork of vim-slime into lfe-slurp to stop and just accept a bit of extra typing.</p>\n\n<p>My attempted solution to the focus problem is simple. For focus, I&rsquo;m using exercism. Each language is on a different track, each has defined tasks to accomplish and progress is tracked. Most tracks have similar tasks, which nicely satisfies my &ldquo;oh man I wonder how I&rsquo;d do this in foo&rdquo; impulse, but in a structured and focused way. Yakshaving is kept to a minimum: while working in racket, I can pop over to another pane, type &ldquo;langjournal,&rdquo; and note a todo about yakshaving vim to work better with it. Later, I can yakshave, but I can keep focused on what I was doing instead of falling down the rabbit hole.</p>\n\n<p>I also have an enormous folder of interesting code laying on my 2tb external harddrive, from language cores and projects to ebooks. I can browse, offline, all the code I could want. Obviously, without structure I could endlessly study this without ever doing anything useful. With even a modicum of enforced structure, this actually becomes useful, instead of a labyrinth through which I&rsquo;m chasing my own tail.</p>\n\n<p>While doing the erlang track, I saw that rebar.config hardcoded rebar3. I did the task, gsubbed rebar3 to rebar (v2 is what I had), and ran the tests. They passed, I made a note. Went on #erlang, asked about rebar3, and decided to upgrade. I bootstrapped it in less than a minute, reverted rebar.config, and it worked as intended. Minimal yakshaving.</p>\n\n<p>I figure as long as I keep things structured, push yakshaving out of the way into its own activity (&ldquo;today I&rsquo;m gonna get vim to work better with lfe&rdquo;), and avoid temptation, I&rsquo;ll have a much nicer time than my usual habits provide. Then, I&rsquo;ll actually get stuff done, comprehensibly, instead of amassing largely useless knowledge.</p>\n\n<p>This blog is going to be part of my workflow, forcing me to maintain a coherency which is usually lost reinventing a local PLEAC.</p>") #f (u . "\n<p>I tend to get flustered when learning languages. I bounce from one to another, trying the same thing in each. &ldquo;oh cool how would I do this in foo? Ah, gotta yakshave my emacs for bar.&rdquo; Since every programming language sucks, I end up endlessly plunging down rabbit holes trying to yakshave things to work properly and smoothly. My focus gets distributed among n languages, m setups, and p annoyances. In this vast space, I end up wandering stochastically and occasionally bumping into useful things. This is no way to conquer a territory and hear the dialup modem screeching lamentations of its robots as you chase them before you.</p>\n\n<p>Little ends up getting done, and I end up working at a cartoonishly slow pace as I bounce around playing with everything. Despite learning, I end up with little to show for it, and the lack of structure means I end up following an interesting avenue and completely neglecting what is usually considered a vital part of the language.</p>\n\n<p>Right now, I&rsquo;m focusing on Racket, Elixir, Clojure, and Common Lisp. oCaml, LFE, and Haskell as background noise, not the main focus. Clojure is a bit lower priority than Elixir; it&rsquo;s just not a good lisp and the dev is not fun on a low-end device. Elixir is a better lisp than clojure and it&rsquo;s not even trying. It didn&rsquo;t even bother to bring its bag full of parentheses to the party and it still kicks clojure&rsquo;s ass. Reminder to rant about this later.</p>\n\n<p>That&rsquo;s a lot of opportunity to get distracted on several levels, from other languages to yakshaving dev environments and workflows for them.</p>\n\n<p>For instance, my normal workflow involves vim-slime and tmux. Vim-slime sends text to a specified tmux pane, it doesn&rsquo;t know or care what repl is on the other end. It doesn&rsquo;t know or care about nrepl or swank or any of that. Just where to dump the text. I prefer this over magic. Well, in LFE slurping a file into the repl dumps all previously slurped macros and defs. The repl is more stateful than most, so the workflow is a little awkward. I was pondering how to tweak vim-slime to have an LFE mode that would on C-c C-c first save, then send over the text (c \"@%\"), or something. I could yakshave on this happily, but it&rsquo;s a distraction. I&rsquo;m trying to minimize as much as possible the temptation to yakshave, so I forced myself mid-fork of vim-slime into lfe-slurp to stop and just accept a bit of extra typing.</p>\n\n<p>My attempted solution to the focus problem is simple. For focus, I&rsquo;m using exercism. Each language is on a different track, each has defined tasks to accomplish and progress is tracked. Most tracks have similar tasks, which nicely satisfies my &ldquo;oh man I wonder how I&rsquo;d do this in foo&rdquo; impulse, but in a structured and focused way. Yakshaving is kept to a minimum: while working in racket, I can pop over to another pane, type &ldquo;langjournal,&rdquo; and note a todo about yakshaving vim to work better with it. Later, I can yakshave, but I can keep focused on what I was doing instead of falling down the rabbit hole.</p>\n\n<p>I also have an enormous folder of interesting code laying on my 2tb external harddrive, from language cores and projects to ebooks. I can browse, offline, all the code I could want. Obviously, without structure I could endlessly study this without ever doing anything useful. With even a modicum of enforced structure, this actually becomes useful, instead of a labyrinth through which I&rsquo;m chasing my own tail.</p>\n\n<p>While doing the erlang track, I saw that rebar.config hardcoded rebar3. I did the task, gsubbed rebar3 to rebar (v2 is what I had), and ran the tests. They passed, I made a note. Went on #erlang, asked about rebar3, and decided to upgrade. I bootstrapped it in less than a minute, reverted rebar.config, and it worked as intended. Minimal yakshaving.</p>\n\n<p>I figure as long as I keep things structured, push yakshaving out of the way into its own activity (&ldquo;today I&rsquo;m gonna get vim to work better with lfe&rdquo;), and avoid temptation, I&rsquo;ll have a much nicer time than my usual habits provide. Then, I&rsquo;ll actually get stuff done, comprehensibly, instead of amassing largely useless knowledge.</p>\n\n<p>This blog is going to be part of my workflow, forcing me to maintain a coherency which is usually lost reinventing a local PLEAC.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-first-post.md" . unix) f post (u . "first post") (? . 1) 1495357660 (p+ #"/home/pook/pookleblinky.github.io/2017/05/first-post.html" . unix) (u . "/2017/05/first-post.html") (u . "2017-05-20T03:41:31") #f (? . 0) (c (u . "meta")) (u . "\n<p>After so long on twitter, I&rsquo;m unused to longform writing, despite all my threads. I&rsquo;m used to expressing things 140 characters at a time, as this paragraph indicates.</p>\n\n<p>This will be my first foray into longform writing in a while. I&rsquo;ll probably end up parasitizing off my twitter threads.</p>\n\n<p>About this site: I figured I wanted to blog, but I never want to leave vim/emacs to do it. Setting up a github static page with Jekyll was the laziest possible way to accomplish this. Literally took 5 minutes.</p>\n\n<p>Edit: Immediately switched to <a href=\"https://github.com/greghendershott/frog\">Frog</a>, which is a static site generator written in Racket which works on Google Pages. Spinning that up was a little more work, as GP doesn&rsquo;t let you simply branch, install an alternate generator, and set that second branch as the display. Still, took only a few minutes.</p>") #f (u . "\n<p>After so long on twitter, I&rsquo;m unused to longform writing, despite all my threads. I&rsquo;m used to expressing things 140 characters at a time, as this paragraph indicates.</p>\n\n<p>This will be my first foray into longform writing in a while. I&rsquo;ll probably end up parasitizing off my twitter threads.</p>\n\n<p>About this site: I figured I wanted to blog, but I never want to leave vim/emacs to do it. Setting up a github static page with Jekyll was the laziest possible way to accomplish this. Literally took 5 minutes.</p>\n\n<p>Edit: Immediately switched to <a href=\"https://github.com/greghendershott/frog\">Frog</a>, which is a static site generator written in Racket which works on Google Pages. Spinning that up was a little more work, as GP doesn&rsquo;t let you simply branch, install an alternate generator, and set that second branch as the display. Still, took only a few minutes.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-frog.md" . unix) f post (u . "Frog") (? . 2) 1495354682 (p+ #"/home/pook/pookleblinky.github.io/2017/05/frog.html" . unix) (u . "/2017/05/frog.html") (u . "2017-05-21T03:41:31") (? . 0) (? . 5) (c (u . "meta") c (u . "scheme")) (u . "\n<p>I made a Frog branch, init&rsquo;d a frog instance, and am now configuring it a bit before attempting to push it to the main site. Dunno exactly how the switch will go, but I can tell it&rsquo;s already a lot nicer than Jekyll.</p>") #t (u . "\n<p>I made a Frog branch, init&rsquo;d a frog instance, and am now configuring it a bit before attempting to push it to the main site. Dunno exactly how the switch will go, but I can tell it&rsquo;s already a lot nicer than Jekyll.</p>\n<!-- more-->")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-20-spinning-it-up.md" . unix) f post (u . "Spinning it up") (? . 0) 1495357710 (p+ #"/home/pook/pookleblinky.github.io/2017/05/spinning-it-up.html" . unix) (u . "/2017/05/spinning-it-up.html") (u . "2017-05-20T03:41:31F") (? . 1) (? . 2) (c (u . "meta")) (u . "\n<p>So, I&rsquo;ve set up a blog. Creating it was the easy part. Configuring it turned out to be more difficult. <a href=\"https://stackoverflow.com/questions/31327045/switch-theme-in-an-existing-jekyll-installation\">Switching from an existing Jekyll layout</a> Turns out to be a pain in the ass. So, I&rsquo;m just not gonna switch.</p>\n\n<p>Then, I broke permalinks, made pages load weird by duplicating the _layouts which the default theme doesn&rsquo;t require (Ah, there&rsquo;s that annoying ruby magic), and then broke more shit. Repeatedly broke shit for a while, seeing what&rsquo;s hidden in the ruby magic. More annoyingly, the localhost preview doesn&rsquo;t indicate some things are broken, you only discover them after pushing to the server. I will probably end up changing from Jekyll, and then building my own static site generator (this seems to be the main sequence of using github pages).</p>\n\n<p>Now I just have to figure out what to write. Years of using twitter have left me unable to write in long chunks. In threads, you still get accustomed to chunking thoughts into small enough pieces to fit into tweets. The luxurious space afforded to a blogpost is overwhelming.</p>\n\n<p>What to write? Well, the question is really what <em>not</em> to write. I write constantly, but in tweets and toots. I need to make writing twitter threads more annoying than writing here.</p>\n\n<p>This is a wonderful opportunity to streamline my workflow, on every level: from editing to git. So many things that can be automated away, so much grudgework eliminated. I have a feeling many of my first posts will just be me discovering new ways to break shit, intentionally or by accident.</p>") #f (u . "\n<p>So, I&rsquo;ve set up a blog. Creating it was the easy part. Configuring it turned out to be more difficult. <a href=\"https://stackoverflow.com/questions/31327045/switch-theme-in-an-existing-jekyll-installation\">Switching from an existing Jekyll layout</a> Turns out to be a pain in the ass. So, I&rsquo;m just not gonna switch.</p>\n\n<p>Then, I broke permalinks, made pages load weird by duplicating the _layouts which the default theme doesn&rsquo;t require (Ah, there&rsquo;s that annoying ruby magic), and then broke more shit. Repeatedly broke shit for a while, seeing what&rsquo;s hidden in the ruby magic. More annoyingly, the localhost preview doesn&rsquo;t indicate some things are broken, you only discover them after pushing to the server. I will probably end up changing from Jekyll, and then building my own static site generator (this seems to be the main sequence of using github pages).</p>\n\n<p>Now I just have to figure out what to write. Years of using twitter have left me unable to write in long chunks. In threads, you still get accustomed to chunking thoughts into small enough pieces to fit into tweets. The luxurious space afforded to a blogpost is overwhelming.</p>\n\n<p>What to write? Well, the question is really what <em>not</em> to write. I write constantly, but in tweets and toots. I need to make writing twitter threads more annoying than writing here.</p>\n\n<p>This is a wonderful opportunity to streamline my workflow, on every level: from editing to git. So many things that can be automated away, so much grudgework eliminated. I have a feeling many of my first posts will just be me discovering new ways to break shit, intentionally or by accident.</p>")) ((? . 3) f post (u . "clojure annoyances, 1") (? . 3) 1495808653 (p+ #"/home/pook/pookleblinky.github.io/2017/05/clojure-annoyances-1.html" . unix) (u . "/2017/05/clojure-annoyances-1.html") (u . "2017-05-26T09:53:03") (? . 4) #f (c (u . "clojure") c (u . "rant")) (u . "\n<p>I use Crouton on a chromebook. Clojure is a pain in the ass on low-end devices. Just annoying as hell, easily hogs all cycles. Lein spins up its own jvm, which adds to the startup time. On a low-end device, you&rsquo;re gonna spin it down in order to such as watch a youtube video, so you really will not have long enough lein sessions to justify such a slow startup. On a heftier box, you don&rsquo;t have to juggle things like that.</p>\n\n<p>The stacktraces, holy shit. I hate Java. Every time I see 100+ lines of java vomitspit I see clojure telling me that it is not a real lisp, that it fundamentally will never understand concurrency, and that it does not intend to follow the Lisp Main Sequence.</p>\n\n<p>The Lisp Main Sequence: All lisps inevitably try to consume their own stack. The normal evolution of a lisp is to ruthlessly divorce itself from its implementation, and become pure lisp. Lisps are like facehuggers. Every normal lisp wants to be lisp all the way down. This isn&rsquo;t a technical thing, it&rsquo;s social. Lisp hackers want to be able to hack lisp all the way down to the silicon. It&rsquo;s engrained into the mindset. Lisp is meant to take over all that it sees, drive its enemies before them, etc. Deep down, even the smallest lisp wants to grow up to be a Genera lisp machine.</p>\n\n<p>The mindset of clojure devs, meanwhile, is not the normal lisp mindset. After almost a decade, they have not taken over the stack. In any normal lisp, a year is sufficient. Clojure devs do not think like normal lispers; something is missing in their personalities. It&rsquo;s downright unsettling to think that for almost a decade clojure hackers have dealt with java regurgitating at them in every stacktrace and <em>put up with it</em> instead of fixing it by replacing it with more clojure. It&rsquo;s disturbing to think of the sheer volume of java vomitspit they have dealt with over the years as something that is perfectly normal in a lisp. It points to a fundamental defect, an inability to really grok lisp. It&rsquo;s lisp for pointy-haired bosses. It&rsquo;s lisp for people who wear ties. Horrifying.</p>\n\n<p>Clojure seems to be at odds with its users. Half are from java, and don&rsquo;t see anything wrong with java being spat at them. Half are from lisps, and <a href=\"http://winestockwebdesign.com/Essays/Lisp_Curse.html\">inevitably try to hack their own mutually incompatible solution</a>. The result is that there will never be a single, united front behind which the pre-gamed lispers can rally persuasively enough to get its benevolent dictator for life to adopt. The result is an incredible inertia compared to most other lisps. The userbase may grow, the number of libraries written in clojure may grow, but fundamentally it will not embrace the main sequence of lisp evolution.</p>\n\n<p>Parodoxically, the inherent expressiveness of clojure (it is still a lisp after all), guarantees that a fuckload of effort will go toward scratching personal itches. New libraries and build tools will appear overnight, because in lisps they can appear overnight. But each must beat not only the java, but the other lisp itch-scratching. This will result in dissatisfied lispers bleeding out of the community in search of a lispier lisp. Before they leave, however, they&rsquo;ll have produced so much sheer output in attempting to scratch their itches that the vast space of options will terrify the java faction. The java faction will similarly bleed off, in search of a more ordered and boss-friendly language.</p>\n\n<p>Who remains? Those who are comfortable with java spewing shit at them, and who are not sufficiently lispy to attempt to hack up a solution in a weekend. Those who for whatever reason are at the borderline between the two mutually-exclusive poles of clojure&rsquo;s community. In <a href=\"https://plus.google.com/110981030061712822816/posts/KaSKeg4vQtz\">Yegge&rsquo;s political spectrum of programming languages</a>, clojure is that weird dude who appeals to both anarchists and the alt-right.</p>\n\n<p>I see clojure increasing in popularity, but I don&rsquo;t see it changing its fundamentally divided nature. It&rsquo;ll have upswings in popularity, but it&rsquo;ll be continually bleeding from both ends. This hemorrhaging may not kill it, but it guarantees inertia. The java people will bleed off into Go or something, the lisp freaks will bleed off into Elixir or something, and the core clojure community will remain just as eventually dissatisfying to both.</p>\n\n<p>Note: I am still interested in clojure, despite these annoyances.</p>") #f (u . "\n<p>I use Crouton on a chromebook. Clojure is a pain in the ass on low-end devices. Just annoying as hell, easily hogs all cycles. Lein spins up its own jvm, which adds to the startup time. On a low-end device, you&rsquo;re gonna spin it down in order to such as watch a youtube video, so you really will not have long enough lein sessions to justify such a slow startup. On a heftier box, you don&rsquo;t have to juggle things like that.</p>\n\n<p>The stacktraces, holy shit. I hate Java. Every time I see 100+ lines of java vomitspit I see clojure telling me that it is not a real lisp, that it fundamentally will never understand concurrency, and that it does not intend to follow the Lisp Main Sequence.</p>\n\n<p>The Lisp Main Sequence: All lisps inevitably try to consume their own stack. The normal evolution of a lisp is to ruthlessly divorce itself from its implementation, and become pure lisp. Lisps are like facehuggers. Every normal lisp wants to be lisp all the way down. This isn&rsquo;t a technical thing, it&rsquo;s social. Lisp hackers want to be able to hack lisp all the way down to the silicon. It&rsquo;s engrained into the mindset. Lisp is meant to take over all that it sees, drive its enemies before them, etc. Deep down, even the smallest lisp wants to grow up to be a Genera lisp machine.</p>\n\n<p>The mindset of clojure devs, meanwhile, is not the normal lisp mindset. After almost a decade, they have not taken over the stack. In any normal lisp, a year is sufficient. Clojure devs do not think like normal lispers; something is missing in their personalities. It&rsquo;s downright unsettling to think that for almost a decade clojure hackers have dealt with java regurgitating at them in every stacktrace and <em>put up with it</em> instead of fixing it by replacing it with more clojure. It&rsquo;s disturbing to think of the sheer volume of java vomitspit they have dealt with over the years as something that is perfectly normal in a lisp. It points to a fundamental defect, an inability to really grok lisp. It&rsquo;s lisp for pointy-haired bosses. It&rsquo;s lisp for people who wear ties. Horrifying.</p>\n\n<p>Clojure seems to be at odds with its users. Half are from java, and don&rsquo;t see anything wrong with java being spat at them. Half are from lisps, and <a href=\"http://winestockwebdesign.com/Essays/Lisp_Curse.html\">inevitably try to hack their own mutually incompatible solution</a>. The result is that there will never be a single, united front behind which the pre-gamed lispers can rally persuasively enough to get its benevolent dictator for life to adopt. The result is an incredible inertia compared to most other lisps. The userbase may grow, the number of libraries written in clojure may grow, but fundamentally it will not embrace the main sequence of lisp evolution.</p>\n\n<p>Parodoxically, the inherent expressiveness of clojure (it is still a lisp after all), guarantees that a fuckload of effort will go toward scratching personal itches. New libraries and build tools will appear overnight, because in lisps they can appear overnight. But each must beat not only the java, but the other lisp itch-scratching. This will result in dissatisfied lispers bleeding out of the community in search of a lispier lisp. Before they leave, however, they&rsquo;ll have produced so much sheer output in attempting to scratch their itches that the vast space of options will terrify the java faction. The java faction will similarly bleed off, in search of a more ordered and boss-friendly language.</p>\n\n<p>Who remains? Those who are comfortable with java spewing shit at them, and who are not sufficiently lispy to attempt to hack up a solution in a weekend. Those who for whatever reason are at the borderline between the two mutually-exclusive poles of clojure&rsquo;s community. In <a href=\"https://plus.google.com/110981030061712822816/posts/KaSKeg4vQtz\">Yegge&rsquo;s political spectrum of programming languages</a>, clojure is that weird dude who appeals to both anarchists and the alt-right.</p>\n\n<p>I see clojure increasing in popularity, but I don&rsquo;t see it changing its fundamentally divided nature. It&rsquo;ll have upswings in popularity, but it&rsquo;ll be continually bleeding from both ends. This hemorrhaging may not kill it, but it guarantees inertia. The java people will bleed off into Go or something, the lisp freaks will bleed off into Elixir or something, and the core clojure community will remain just as eventually dissatisfying to both.</p>\n\n<p>Note: I am still interested in clojure, despite these annoyances.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-21-git-koans.md" . unix) f post (u . "Git koans") (? . 5) 1495414206 (p+ #"/home/pook/pookleblinky.github.io/2017/05/git-koans.html" . unix) (u . "/2017/05/git-koans.html") (u . "2017-05-21T18:59:32") (? . 2) (? . 6) (c (u . "git") c (u . "coding") c (u . "rant")) (u . "\n<p>Git Koans don&rsquo;t really exist. I can&rsquo;t be arsed to make it, though. There are some anecdotes called Git Koans, but as far as I can tell there is nothing similar to Clojure/Ruby Koans where you get hands-on experience fixing things incrementally, from tiny mistakes all the way up the ladder.</p>\n\n<p>Basically: &ldquo;Here&rsquo;s broken shit. Fix it.&rdquo; &ldquo;Yay, you fixed it. Here&rsquo;s more broken shit. Fix it.&rdquo; Turn on continuous integration and use post-commit hooks as the koan runner. Eventually, you fix all the problems in the broken repo.</p>\n\n<p>It actually wouldn&rsquo;t be very hard. You can pretty much use any kind of make system to build a repo then fuck it up per order. The result would be hands-on experience fixing fuckups in git, from small to huge. Hell: a joker shell script that takes all the commands used to evolve a repo, and randomly inserts typos and wrong commands to fuck it up (Maybe just swap the entered command with one which is often accidentally typed instead). &ldquo;Here&rsquo;s a fork of Foo that&rsquo;s been utterly fucked. Walk through its history and unfuck it.&rdquo;</p>\n\n<p>You could also do local/remote fuckups pretty easily too. Have a shell script that purposely messes up upstream/downstream relations, purposely screws up a merge, etc. Nightmare mode: multiple remotes are created, each randomly screwed up to simulate others trying, unsuccessfully, to fix their own messed up repos.</p>\n\n<p>As far as I can tell, this doesn&rsquo;t exist. The only time you&rsquo;re ever fixing a fuckup is in actual goddamn repos during your job. The <em>only</em> time you will ever unfuck an arbitrarily broken repo is when your ass depends on it.</p>\n\n<p>This means that for most people, git is a <a href=\"https://people.csail.mit.edu/sperezde/oopsla16.pdf\">cargo cult</a>. You don&rsquo;t know how to unfuck things, you&rsquo;re doing shit like cp -R repo repo.old. Imagine if you wrote code this way: the <em>only</em> time you ever fix bugs is in production code. The only time you ever fix a bug is when your ass is on the line. You&rsquo;d also do cargo cult bullshit. You&rsquo;d be that happy asshole sloppily commenting out lines of code to see what&rsquo;s wrong. In $Lang the Hard Way style tutorials, it&rsquo;s heavily emphasized that you should break stuff in order to learn what happens, and how to fix it when you do inevitably do it by accident. Yet, I would put money on the bet that the vast majority of git users have never purposely broken a repo in order to learn how to fix it. How many purposely messed up a commit or 3 in order to get hands-on experience with git reflog? How many intentionally committed to the wrong branch so they could learn how to stash pop. How many purposely introduced a painful merge conflict in order to learn the right (painless) way to resolve it? Purposely broke the build in order to learn how to use bisect?</p>\n\n<p>In code, it&rsquo;s unthinkable that you would have no experience of fixing bugs outside of &ldquo;we need this fixed yesterday&rdquo; situations. Yet with git, that&rsquo;s the case. No experience, at all, of unfucking repos that you don&rsquo;t depend on for rent or whatever. The average git user has no idea how to fix mistakes they make, and every mistake they do have to fix is only ever on a real repo.</p>\n\n<p>Look at <a href=\"http://ohshitgit.com/\">Oh Shit Git</a>. It lists very common mistakes, in plain English, and explains how to fix them. I guarantee that the vast majority of git users have never <em>purposely</em> made those mistakes in order to see how to fix them. For many, the first time they have to fix a mistake, that mistake is new to them and they end up on ohshitgit or stackoverflow typing commands that may as well be mystic incantations.</p>") #f (u . "\n<p>Git Koans don&rsquo;t really exist. I can&rsquo;t be arsed to make it, though. There are some anecdotes called Git Koans, but as far as I can tell there is nothing similar to Clojure/Ruby Koans where you get hands-on experience fixing things incrementally, from tiny mistakes all the way up the ladder.</p>\n\n<p>Basically: &ldquo;Here&rsquo;s broken shit. Fix it.&rdquo; &ldquo;Yay, you fixed it. Here&rsquo;s more broken shit. Fix it.&rdquo; Turn on continuous integration and use post-commit hooks as the koan runner. Eventually, you fix all the problems in the broken repo.</p>\n\n<p>It actually wouldn&rsquo;t be very hard. You can pretty much use any kind of make system to build a repo then fuck it up per order. The result would be hands-on experience fixing fuckups in git, from small to huge. Hell: a joker shell script that takes all the commands used to evolve a repo, and randomly inserts typos and wrong commands to fuck it up (Maybe just swap the entered command with one which is often accidentally typed instead). &ldquo;Here&rsquo;s a fork of Foo that&rsquo;s been utterly fucked. Walk through its history and unfuck it.&rdquo;</p>\n\n<p>You could also do local/remote fuckups pretty easily too. Have a shell script that purposely messes up upstream/downstream relations, purposely screws up a merge, etc. Nightmare mode: multiple remotes are created, each randomly screwed up to simulate others trying, unsuccessfully, to fix their own messed up repos.</p>\n\n<p>As far as I can tell, this doesn&rsquo;t exist. The only time you&rsquo;re ever fixing a fuckup is in actual goddamn repos during your job. The <em>only</em> time you will ever unfuck an arbitrarily broken repo is when your ass depends on it.</p>\n\n<p>This means that for most people, git is a <a href=\"https://people.csail.mit.edu/sperezde/oopsla16.pdf\">cargo cult</a>. You don&rsquo;t know how to unfuck things, you&rsquo;re doing shit like cp -R repo repo.old. Imagine if you wrote code this way: the <em>only</em> time you ever fix bugs is in production code. The only time you ever fix a bug is when your ass is on the line. You&rsquo;d also do cargo cult bullshit. You&rsquo;d be that happy asshole sloppily commenting out lines of code to see what&rsquo;s wrong. In $Lang the Hard Way style tutorials, it&rsquo;s heavily emphasized that you should break stuff in order to learn what happens, and how to fix it when you do inevitably do it by accident. Yet, I would put money on the bet that the vast majority of git users have never purposely broken a repo in order to learn how to fix it. How many purposely messed up a commit or 3 in order to get hands-on experience with git reflog? How many intentionally committed to the wrong branch so they could learn how to stash pop. How many purposely introduced a painful merge conflict in order to learn the right (painless) way to resolve it? Purposely broke the build in order to learn how to use bisect?</p>\n\n<p>In code, it&rsquo;s unthinkable that you would have no experience of fixing bugs outside of &ldquo;we need this fixed yesterday&rdquo; situations. Yet with git, that&rsquo;s the case. No experience, at all, of unfucking repos that you don&rsquo;t depend on for rent or whatever. The average git user has no idea how to fix mistakes they make, and every mistake they do have to fix is only ever on a real repo.</p>\n\n<p>Look at <a href=\"http://ohshitgit.com/\">Oh Shit Git</a>. It lists very common mistakes, in plain English, and explains how to fix them. I guarantee that the vast majority of git users have never <em>purposely</em> made those mistakes in order to see how to fix them. For many, the first time they have to fix a mistake, that mistake is new to them and they end up on ohshitgit or stackoverflow typing commands that may as well be mystic incantations.</p>")) ((p+ #"/home/pook/pookleblinky.github.io/_src/posts/2017-05-23-exercism.md" . unix) f post (u . "Exercism") (? . 6) 1495576210 (p+ #"/home/pook/pookleblinky.github.io/2017/05/exercism.html" . unix) (u . "/2017/05/exercism.html") (u . "2017-05-23T17:39:35") (? . 5) (? . 4) (c (u . "resources")) (u . "\n<p>On #Racket, samth linked to <a href=\"http://exercism.io/languages/racket\">Exercism</a>, a wonderful analog to $LANG Koans. Each exercise is a basic, small program which you code by satisfying the unit tests. Unlike, say, Clojure Koans, <a href=\"http://exercism.io/languages/clojure\">the Clojure Track of Exercism</a> has you create 58 programs of various degrees of complexity, rather than a running through individual test assertions.</p>\n\n<p>You code enough to pass the tests, then submit. You can keep tweaking your solution, and keep submitting it. On your dashboard, you&rsquo;ll be able to see how your solution has evolved over time. You can also look at how other people solved the problem, discuss solutions, etc.</p>\n\n<p>Exercism, with its emphasis on creating programs and then discussing them, is an even better way to introduce a language than a standard koan runner. Especially considering that if you already know the language, instead of solving the exercises you can easily submit new ones for others to solve.</p>") #f (u . "\n<p>On #Racket, samth linked to <a href=\"http://exercism.io/languages/racket\">Exercism</a>, a wonderful analog to $LANG Koans. Each exercise is a basic, small program which you code by satisfying the unit tests. Unlike, say, Clojure Koans, <a href=\"http://exercism.io/languages/clojure\">the Clojure Track of Exercism</a> has you create 58 programs of various degrees of complexity, rather than a running through individual test assertions.</p>\n\n<p>You code enough to pass the tests, then submit. You can keep tweaking your solution, and keep submitting it. On your dashboard, you&rsquo;ll be able to see how your solution has evolved over time. You can also look at how other people solved the problem, discuss solutions, etc.</p>\n\n<p>Exercism, with its emphasis on creating programs and then discussing them, is an even better way to introduce a language than a standard koan runner. Especially considering that if you already know the language, instead of solving the exercises you can easily submit new ones for others to solve.</p>"))))