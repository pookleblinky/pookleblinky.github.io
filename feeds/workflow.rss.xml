<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Mistake Not: Posts tagged 'workflow'</title>
  <description>Mistake Not: Posts tagged 'workflow'</description>
  <link>http://pookleblinky.github.io/tags/workflow.html</link>
  <lastBuildDate>Mon, 29 May 2017 17:13:40 UT</lastBuildDate>
  <pubDate>Mon, 29 May 2017 17:13:40 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>orgmode</title>
   <link>http://pookleblinky.github.io/2017/05/orgmode.html?utm_source=workflow&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-pookleblinky-github-io:-2017-05-orgmode-html</guid>
   <pubDate>Mon, 29 May 2017 17:13:40 UT</pubDate>
   <author>Pookleblinky</author>
   <description>
&lt;p&gt;I&amp;rsquo;m spending some time getting org-mode configured the way I want. I&amp;rsquo;m trying to keep things as simple as possible, given how much yakshave potential there is in org mode. I have only a few files in ~/org:  orgfile.org  blog.org  code.org  refile.org&lt;/p&gt;

&lt;p&gt;Orgfile.org, which is the default general agenda file. It&amp;rsquo;s structured like this:  datetree  links  notes  tasks  orgstuff My blog.org is just a datetree.&lt;/p&gt;

&lt;p&gt;Code.org is tough to figure out how to structure it. I initially thought of organizing by language, but I don&amp;rsquo;t like how that lacks telos. It encourages dicking around with no goal, just bouncing from thing to thing. I could organize by project, but that similarly lacks focus if there are multiple projects to bounce around in. I settled on just a datetree and tags. A datetree encourages a daily log of what I intend to do, what I actually did, and where I am going. I can just filter by tags and date until this becomes insufficient and I need to split off a project, in which case I&amp;rsquo;d rather add it to code.org instead of making a new orgfile. Again, I want to try as hard as possible to discourage dicking around bouncing from one thing to another without a goal.&lt;/p&gt;</description></item>
  <item>
   <title>languages</title>
   <link>http://pookleblinky.github.io/2017/05/languages.html?utm_source=workflow&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-pookleblinky-github-io:-2017-05-languages-html</guid>
   <pubDate>Fri, 26 May 2017 07:04:55 UT</pubDate>
   <author>Pookleblinky</author>
   <description>
&lt;p&gt;I tend to get flustered when learning languages. I bounce from one to another, trying the same thing in each. &amp;ldquo;oh cool how would I do this in foo? Ah, gotta yakshave my emacs for bar.&amp;rdquo; Since every programming language sucks, I end up endlessly plunging down rabbit holes trying to yakshave things to work properly and smoothly. My focus gets distributed among n languages, m setups, and p annoyances. In this vast space, I end up wandering stochastically and occasionally bumping into useful things. This is no way to conquer a territory and hear the dialup modem screeching lamentations of its robots as you chase them before you.&lt;/p&gt;

&lt;p&gt;Little ends up getting done, and I end up working at a cartoonishly slow pace as I bounce around playing with everything. Despite learning, I end up with little to show for it, and the lack of structure means I end up following an interesting avenue and completely neglecting what is usually considered a vital part of the language.&lt;/p&gt;

&lt;p&gt;Right now, I&amp;rsquo;m focusing on Racket, Elixir, Clojure, and Common Lisp. oCaml, LFE, and Haskell as background noise, not the main focus. Clojure is a bit lower priority than Elixir; it&amp;rsquo;s just not a good lisp and the dev is not fun on a low-end device. Elixir is a better lisp than clojure and it&amp;rsquo;s not even trying. It didn&amp;rsquo;t even bother to bring its bag full of parentheses to the party and it still kicks clojure&amp;rsquo;s ass. Reminder to rant about this later.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a lot of opportunity to get distracted on several levels, from other languages to yakshaving dev environments and workflows for them.&lt;/p&gt;

&lt;p&gt;For instance, my normal workflow involves vim-slime and tmux. Vim-slime sends text to a specified tmux pane, it doesn&amp;rsquo;t know or care what repl is on the other end. It doesn&amp;rsquo;t know or care about nrepl or swank or any of that. Just where to dump the text. I prefer this over magic. Well, in LFE slurping a file into the repl dumps all previously slurped macros and defs. The repl is more stateful than most, so the workflow is a little awkward. I was pondering how to tweak vim-slime to have an LFE mode that would on C-c C-c first save, then send over the text (c "@%"), or something. I could yakshave on this happily, but it&amp;rsquo;s a distraction. I&amp;rsquo;m trying to minimize as much as possible the temptation to yakshave, so I forced myself mid-fork of vim-slime into lfe-slurp to stop and just accept a bit of extra typing.&lt;/p&gt;

&lt;p&gt;My attempted solution to the focus problem is simple. For focus, I&amp;rsquo;m using exercism. Each language is on a different track, each has defined tasks to accomplish and progress is tracked. Most tracks have similar tasks, which nicely satisfies my &amp;ldquo;oh man I wonder how I&amp;rsquo;d do this in foo&amp;rdquo; impulse, but in a structured and focused way. Yakshaving is kept to a minimum: while working in racket, I can pop over to another pane, type &amp;ldquo;langjournal,&amp;rdquo; and note a todo about yakshaving vim to work better with it. Later, I can yakshave, but I can keep focused on what I was doing instead of falling down the rabbit hole.&lt;/p&gt;

&lt;p&gt;I also have an enormous folder of interesting code laying on my 2tb external harddrive, from language cores and projects to ebooks. I can browse, offline, all the code I could want. Obviously, without structure I could endlessly study this without ever doing anything useful. With even a modicum of enforced structure, this actually becomes useful, instead of a labyrinth through which I&amp;rsquo;m chasing my own tail.&lt;/p&gt;

&lt;p&gt;While doing the erlang track, I saw that rebar.config hardcoded rebar3. I did the task, gsubbed rebar3 to rebar (v2 is what I had), and ran the tests. They passed, I made a note. Went on #erlang, asked about rebar3, and decided to upgrade. I bootstrapped it in less than a minute, reverted rebar.config, and it worked as intended. Minimal yakshaving.&lt;/p&gt;

&lt;p&gt;I figure as long as I keep things structured, push yakshaving out of the way into its own activity (&amp;ldquo;today I&amp;rsquo;m gonna get vim to work better with lfe&amp;rdquo;), and avoid temptation, I&amp;rsquo;ll have a much nicer time than my usual habits provide. Then, I&amp;rsquo;ll actually get stuff done, comprehensibly, instead of amassing largely useless knowledge.&lt;/p&gt;

&lt;p&gt;This blog is going to be part of my workflow, forcing me to maintain a coherency which is usually lost reinventing a local PLEAC.&lt;/p&gt;</description></item></channel></rss>